// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// prisma/schema.prisma
model User {
  id                 String          @id @default(cuid())
  email              String          @unique
  name               String
  password           String?
  avatar             String?
  isEmailVerified    Boolean         @default(false)
  emailVerifiedAt    DateTime?
  verificationToken  String?         @unique
  twoFactorSecret    String?
  resetToken         String?         @unique
  resetTokenExpires  DateTime?
  isTwoFactorEnabled Boolean         @default(false)
  backupCodes        String[]        @default([])
  roles              String[]        @default(["user"])
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  sgtmContainers     SgtmContainer[] @relation("UserContainers")

  // Relations for impersonation
  impersonationSessionsAsAdmin  ImpersonationSession[] @relation("ImpersonationSessionAsAdmin")
  impersonationSessionsAsTarget ImpersonationSession[] @relation("ImpersonationSessionAsTarget")
  impersonationAuditsAsAdmin    ImpersonationAudit[]   @relation("ImpersonationAuditAsAdmin")
  impersonationAuditsAsTarget   ImpersonationAudit[]   @relation("ImpersonationAuditAsTarget")

  // Relations for access logging
  accessLogs AccessLog[] @relation("UserAccessLogs")

  // Relations for Meta CAPI containers
  metaCapiContainers MetaCapiContainer[] @relation("UserMetaCapiContainers")

  // Relations for multiple auth providers
  authProviders AuthProvider[]

  // Relations for session management
  sessions  UserSession[]
  AccessLog AccessLog[]

  // Relations for support ticket system
  supportTickets    SupportTicket[]       @relation("CreatedTickets")
  assignedTickets   SupportTicket[]       @relation("AssignedTickets")
  ticketReplies     TicketReply[]         @relation("ReplyAuthors")
  reopenRequests    TicketReopenRequest[] @relation("ReopenRequesters")
  reopenReviews     TicketReopenRequest[] @relation("ReopenReviewers")
  MetaCapiContainer MetaCapiContainer[]
  FileMetadata      FileMetadata[]

  @@map("users")
}

model AuthProvider {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Provider details
  provider   AuthProviderType // Auth provider type
  providerId String // OAuth provider's user ID (e.g., googleId, facebookId)
  email      String? // Email from provider (may differ from user's email)

  // OAuth tokens and data
  accessToken    String?
  refreshToken   String?
  tokenExpiresAt DateTime?

  // Provider-specific data stored as JSON
  providerData Json? // Additional provider-specific data

  // Metadata
  isPrimary  Boolean   @default(false) // Whether this is the user's primary provider
  linkedAt   DateTime  @default(now())
  lastUsedAt DateTime?

  @@unique([userId, provider]) // One provider type per user
  @@index([userId])
  @@index([provider])
  @@index([providerId])
  @@map("auth_providers")
}

// User Sessions for tracking active login sessions
model UserSession {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Session metadata
  sessionId  String  @unique // Unique identifier for this session
  deviceInfo Json? // Device fingerprinting data (OS, browser, etc.)
  ipAddress  String?
  userAgent  String?
  location   String? // Geolocation data if available

  // Enhanced security fields
  browserFingerprintHash      String? // Hash of browser fingerprint for device tracking
  deviceFingerprintConfidence Float?  @default(0.5) // Confidence level (0-1) in device fingerprint
  latitude                    Float? // Geographic latitude
  longitude                   Float? // Geographic longitude
  timezone                    String? // User's timezone
  riskScore                   Float   @default(0) // Session risk score (0-1, higher = more suspicious)

  // Access pattern tracking
  lastIpChangeAt       DateTime? // When IP address last changed
  accessCount          Int       @default(0) // Number of access events in current session
  unusualActivityCount Int       @default(0) // Count of unusual activities detected

  // Session status
  isActive     Boolean  @default(true)
  expiresAt    DateTime
  lastActivity DateTime @default(now())

  // Session configuration
  rememberMe Boolean @default(false)

  // Invalidation tracking
  invalidatedAt      DateTime? // When session was invalidated
  invalidationReason String? // Reason for invalidation (suspicious_activity, ip_change, etc.)

  // Relations
  refreshTokens RefreshToken[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([sessionId])
  @@index([expiresAt])
  @@index([isActive])
  @@index([riskScore])
  @@index([browserFingerprintHash])
  @@map("user_sessions")
}

// Refresh Tokens for secure token management
model RefreshToken {
  id        String      @id @default(cuid())
  sessionId String
  session   UserSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Token data
  tokenHash   String  @unique // Hashed refresh token for security
  tokenFamily String? // For token rotation (each refresh generates new family)

  // Token status
  isActive  Boolean   @default(true)
  usedAt    DateTime? // When was this token last used for refresh
  expiresAt DateTime

  // Metadata for security
  ipAddress String? // IP from which token was created
  userAgent String? // User agent when token was created

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
  @@index([tokenHash])
  @@index([expiresAt])
  @@index([isActive])
  @@map("refresh_tokens")
}

model SgtmContainer {
  id          String          @id @default(cuid())
  name        String
  fullName    String?
  containerId String? // Docker container ID
  userId      String
  user        User            @relation("UserContainers", fields: [userId], references: [id])
  status      ContainerStatus @default(CREATED)
  subdomain   String? // e.g., tags.bikobazaar.xyz
  config      String? // base64-encoded config string
  regionKey   String
  region      SgtmRegion      @relation(fields: [regionKey], references: [key])
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([regionKey])
  @@map("sgtm_containers")
}

model MetaCapiContainer {
  id          String          @id @default(cuid())
  name        String
  fullName    String?
  fbPixelId   String // Facebook Pixel ID
  accessToken String // Facebook API Access Token
  testCode    String? // Optional test code for Facebook API
  userId      String
  user        User            @relation("UserMetaCapiContainers", fields: [userId], references: [id])
  status      ContainerStatus @default(CREATED)
  regionKey   String
  region      MetaCapiRegion  @relation(fields: [regionKey], references: [key])
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  User        User            @relation(fields: [userId], references: [id], map: "meta_capi_containers_user_id_fkey2")

  @@index([regionKey])
  @@map("meta_capi_containers")
}

model SgtmRegion {
  id          String   @id @default(cuid())
  key         String   @unique // e.g., 'india', 'us-east', 'us-west', 'europe'
  name        String // Display name e.g., 'India', 'US East'
  apiUrl      String // REST API URL for the region
  apiKey      String // API key for the region
  isActive    Boolean  @default(true) // Whether region is available
  isDefault   Boolean  @default(false) // Whether this is the default region
  description String? // Optional description
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  containers SgtmContainer[]

  @@index([key])
  @@index([isActive])
  @@index([isDefault])
  @@map("sgtm_regions")
}

model MetaCapiRegion {
  id          String   @id @default(cuid())
  key         String   @unique // e.g., 'us', 'eu', 'asia'
  name        String // Display name e.g., 'US', 'EU'
  baseUrl     String // Base API URL for Conversions API
  appId       String // Facebook App ID
  appSecret   String // Facebook App Secret (encrypted)
  apiVersion  String   @default("v16.0") // API version
  isActive    Boolean  @default(true) // Whether region is available
  isDefault   Boolean  @default(false) // Whether this is the default region
  description String? // Optional description
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  containers MetaCapiContainer[]

  @@index([key])
  @@index([isActive])
  @@index([isDefault])
  @@map("meta_capi_regions")
}

// Support Ticket System Enums
enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum Priority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum ReopenStatus {
  PENDING
  APPROVED
  REJECTED
}

enum TicketType {
  GENERAL
  TECHNICAL
  BILLING
  FEEDBACK
}

// Support Ticket System Models
model SupportTicket {
  id          String       @id @default(cuid())
  title       String
  description String?
  status      TicketStatus @default(OPEN)
  priority    Priority     @default(NORMAL)
  type        TicketType   @default(GENERAL)

  createdById String
  createdBy   User   @relation("CreatedTickets", fields: [createdById], references: [id])

  assignedToId String?
  assignedTo   User?     @relation("AssignedTickets", fields: [assignedToId], references: [id])
  assignedAt   DateTime?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  closedAt  DateTime?

  replies        TicketReply[]
  reopenRequests TicketReopenRequest[]

  fileUrls     String[]       @default([])
  FileMetadata FileMetadata[]

  @@index([status])
  @@index([priority])
  @@index([createdById])
  @@index([assignedToId])
  @@map("support_tickets")
}

model TicketReply {
  id       String        @id @default(cuid())
  ticketId String
  ticket   SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  authorId String
  author   User   @relation("ReplyAuthors", fields: [authorId], references: [id])

  content    String
  isInternal Boolean @default(false)

  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  fileUrls     String[]       @default([])
  FileMetadata FileMetadata[]

  @@index([ticketId])
  @@index([authorId])
  @@map("ticket_replies")
}

model TicketReopenRequest {
  id       String        @id @default(cuid())
  ticketId String
  ticket   SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  requestedById String
  requestedBy   User   @relation("ReopenRequesters", fields: [requestedById], references: [id])

  reason String
  status ReopenStatus @default(PENDING)

  reviewedById String?
  reviewedBy   User?   @relation("ReopenReviewers", fields: [reviewedById], references: [id])

  reviewedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ticketId])
  @@index([requestedById])
  @@index([status])
  @@map("ticket_reopen_requests")
}

model FileMetadata {
  id           String @id @default(cuid())
  filename     String
  originalName String
  mimeType     String
  size         Int
  path         String

  category         String?
  securityStatus   String?
  processingStatus String?

  // Storage provider fields
  storageProvider String
  storageKey      String? @unique
  storageUrl      String?

  createdAt       DateTime       @default(now())
  User            User?          @relation(fields: [userId], references: [id])
  userId          String?
  SupportTicket   SupportTicket? @relation(fields: [supportTicketId], references: [id])
  supportTicketId String?
  TicketReply     TicketReply?   @relation(fields: [ticketReplyId], references: [id])
  ticketReplyId   String?

  @@index([category])
  @@index([securityStatus])
  @@index([processingStatus])
  @@index([createdAt])
  @@index([storageProvider])
  @@index([storageKey])
  @@index([storageProvider, createdAt])
  @@map("file_metadata")
}

enum ContainerStatus {
  CREATED
  PENDING
  RUNNING
  STOPPED
  ERROR
  DELETED
}

enum AuthProviderType {
  LOCAL
  GOOGLE
  FACEBOOK
  GITHUB
  TWITTER
  LINKEDIN
  MICROSOFT
  APPLE
}

model ImpersonationSession {
  id        String   @id @default(cuid())
  adminId   String
  targetId  String   @unique
  startedAt DateTime @default(now())
  expiresAt DateTime
  reason    String?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Explicit relation names to resolve ambiguity
  admin  User @relation("ImpersonationSessionAsAdmin", fields: [adminId], references: [id])
  target User @relation("ImpersonationSessionAsTarget", fields: [targetId], references: [id])

  @@index([adminId])
  @@index([targetId])
  @@index([expiresAt])
}

model ImpersonationAudit {
  id          String   @id @default(cuid())
  adminId     String
  adminEmail  String
  targetId    String
  targetEmail String
  action      String // 'start' or 'stop'
  reason      String?
  ipAddress   String?
  userAgent   String?
  timestamp   DateTime @default(now())
  createdAt   DateTime @default(now())

  // Explicit relation names
  admin  User @relation("ImpersonationAuditAsAdmin", fields: [adminId], references: [id])
  target User @relation("ImpersonationAuditAsTarget", fields: [targetId], references: [id])

  @@index([adminId, timestamp])
  @@index([targetId, timestamp])
  @@index([action, timestamp])
}

// Access Log for tracking authentication events
model AccessLog {
  id     String @id @default(cuid())
  userId String
  user   User   @relation("UserAccessLogs", fields: [userId], references: [id], onDelete: Cascade, map: "access_logs_user_id_fkey")

  // Event details
  event     AccessEvent
  sessionId String? // Reference to user session if available
  ipAddress String?
  userAgent String?

  // Additional context
  location      String? // Geolocation data if available
  deviceInfo    Json? // Device/browser information
  success       Boolean @default(true) // Whether the event was successful
  failureReason String? // Reason for failure if success=false

  // Metadata
  timestamp DateTime @default(now())
  User      User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([sessionId])
  @@index([event])
  @@index([timestamp])
  @@index([userId, event])
  @@map("access_logs")
}

enum AccessEvent {
  LOGIN_SUCCESS
  LOGIN_FAILED
  LOGOUT
  TOKEN_REFRESH
  PASSWORD_RESET_REQUEST
  PASSWORD_RESET_SUCCESS
  PASSWORD_CHANGE
  SESSION_EXPIRED
  SESSION_INVALIDATED
  TWO_FACTOR_ENABLED
  TWO_FACTOR_DISABLED
  BACKUP_CODE_USED
  PROVIDER_LINKED
  PROVIDER_UNLINKED
  IMPERSONATION_START
  IMPERSONATION_END
  // Enhanced security events
  SUSPICIOUS_ACTIVITY_DETECTED
  IP_ADDRESS_CHANGED
  DEVICE_FINGERPRINT_CHANGED
  GEOLOCATION_CHANGED
  UNUSUAL_ACCESS_PATTERN
  SESSION_CONCURRENCY_LIMIT_EXCEEDED
  SESSION_RISK_SCORE_INCREASED
  SECURITY_ALERT_TRIGGERED
  DEVICE_FINGERPRINT_CAPTURED
  SESSION_ACTIVITY_MONITORED
  ACCOUNT_SECURITY_UPDATED
}
