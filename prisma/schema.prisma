// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// prisma/schema.prisma
model User {
  id                 String          @id @default(cuid())
  email              String          @unique
  name               String
  password           String?
  avatar             String?
  isEmailVerified    Boolean         @default(false)
  emailVerifiedAt    DateTime?
  verificationToken  String?         @unique
  refreshTokenHash   String?
  twoFactorSecret    String?
  resetToken         String?         @unique
  resetTokenExpires  DateTime?
  isTwoFactorEnabled Boolean         @default(false)
  backupCodes        String[]        @default([])
  roles              String[]        @default(["user"])
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  sgtmContainers     SgtmContainer[] @relation("UserContainers")

  // Relations for impersonation
  impersonationSessionsAsAdmin  ImpersonationSession[] @relation("ImpersonationSessionAsAdmin")
  impersonationSessionsAsTarget ImpersonationSession[] @relation("ImpersonationSessionAsTarget")
  impersonationAuditsAsAdmin    ImpersonationAudit[]   @relation("ImpersonationAuditAsAdmin")
  impersonationAuditsAsTarget   ImpersonationAudit[]   @relation("ImpersonationAuditAsTarget")

  // Relations for multiple auth providers
  authProviders AuthProvider[]

  // Relations for session management
  sessions UserSession[]

  @@map("users")
}

model AuthProvider {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Provider details
  provider   AuthProviderType // Auth provider type
  providerId String // OAuth provider's user ID (e.g., googleId, facebookId)
  email      String? // Email from provider (may differ from user's email)

  // OAuth tokens and data
  accessToken    String?
  refreshToken   String?
  tokenExpiresAt DateTime?

  // Provider-specific data stored as JSON
  providerData Json? // Additional provider-specific data

  // Metadata
  isPrimary  Boolean   @default(false) // Whether this is the user's primary provider
  linkedAt   DateTime  @default(now())
  lastUsedAt DateTime?

  @@unique([userId, provider]) // One provider type per user
  @@index([userId])
  @@index([provider])
  @@index([providerId])
  @@map("auth_providers")
}

// User Sessions for tracking active login sessions
model UserSession {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Session metadata
  sessionId  String  @unique // Unique identifier for this session
  deviceInfo Json? // Device fingerprinting data (OS, browser, etc.)
  ipAddress  String?
  userAgent  String?
  location   String? // Geolocation data if available

  // Session status
  isActive     Boolean  @default(true)
  expiresAt    DateTime
  lastActivity DateTime @default(now())

  // Session configuration
  rememberMe Boolean @default(false)

  // Relations
  refreshTokens RefreshToken[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([sessionId])
  @@index([expiresAt])
  @@index([isActive])
  @@map("user_sessions")
}

// Refresh Tokens for secure token management
model RefreshToken {
  id        String      @id @default(cuid())
  sessionId String
  session   UserSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Token data
  tokenHash   String  @unique // Hashed refresh token for security
  tokenFamily String? // For token rotation (each refresh generates new family)

  // Token status
  isActive  Boolean   @default(true)
  usedAt    DateTime? // When was this token last used for refresh
  expiresAt DateTime

  // Metadata for security
  ipAddress String? // IP from which token was created
  userAgent String? // User agent when token was created

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
  @@index([tokenHash])
  @@index([expiresAt])
  @@index([isActive])
  @@map("refresh_tokens")
}

model SgtmContainer {
  id          String          @id @default(cuid())
  name        String
  fullName    String?
  containerId String? // Docker container ID
  userId      String
  user        User            @relation("UserContainers", fields: [userId], references: [id])
  status      ContainerStatus @default(CREATED)
  subdomain   String? // e.g., tags.bikobazaar.xyz
  config      String? // base64-encoded config string
  region      String          @default("india") // Region where container is deployed
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@map("sgtm_containers")
}

model SgtmRegion {
  id          String   @id @default(cuid())
  key         String   @unique // e.g., 'india', 'us-east', 'us-west', 'europe'
  name        String // Display name e.g., 'India', 'US East'
  apiUrl      String // REST API URL for the region
  apiKey      String // API key for the region
  isActive    Boolean  @default(true) // Whether region is available
  isDefault   Boolean  @default(false) // Whether this is the default region
  description String? // Optional description
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("sgtm_regions")
}

enum ContainerStatus {
  CREATED
  PENDING
  RUNNING
  STOPPED
  ERROR
  DELETED
}

enum AuthProviderType {
  LOCAL
  GOOGLE
  FACEBOOK
  GITHUB
  TWITTER
  LINKEDIN
  MICROSOFT
  APPLE
}

model ImpersonationSession {
  id        String   @id @default(cuid())
  adminId   String
  targetId  String   @unique
  startedAt DateTime @default(now())
  expiresAt DateTime
  reason    String?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Explicit relation names to resolve ambiguity
  admin  User @relation("ImpersonationSessionAsAdmin", fields: [adminId], references: [id])
  target User @relation("ImpersonationSessionAsTarget", fields: [targetId], references: [id])

  @@index([adminId])
  @@index([targetId])
  @@index([expiresAt])
}

model ImpersonationAudit {
  id          String   @id @default(cuid())
  adminId     String
  adminEmail  String
  targetId    String
  targetEmail String
  action      String // 'start' or 'stop'
  reason      String?
  ipAddress   String?
  userAgent   String?
  timestamp   DateTime @default(now())
  createdAt   DateTime @default(now())

  // Explicit relation names
  admin  User @relation("ImpersonationAuditAsAdmin", fields: [adminId], references: [id])
  target User @relation("ImpersonationAuditAsTarget", fields: [targetId], references: [id])

  @@index([adminId, timestamp])
  @@index([targetId, timestamp])
  @@index([action, timestamp])
}
